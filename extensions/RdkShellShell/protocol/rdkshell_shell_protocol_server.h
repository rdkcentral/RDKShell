/* Generated by wayland-scanner 1.18.0 */

#ifndef RDKSHELL_SHELL_SERVER_PROTOCOL_H
#define RDKSHELL_SHELL_SERVER_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-server.h"

#ifdef  __cplusplus
extern "C" {
#endif

struct wl_client;
struct wl_resource;

/**
 * @page page_rdkshell_shell The rdkshell_shell protocol
 * @section page_ifaces_rdkshell_shell Interfaces
 * - @subpage page_iface_rdkshell_shell - 
 * @section page_copyright_rdkshell_shell Copyright
 * <pre>
 *
 * Copyright 2022 RDK Management
 * </pre>
 */
struct rdkshell_shell;

/**
 * @page page_iface_rdkshell_shell rdkshell_shell
 * @section page_iface_rdkshell_shell_api API
 * See @ref iface_rdkshell_shell.
 */
/**
 * @defgroup iface_rdkshell_shell The rdkshell_shell interface
 */
extern const struct wl_interface rdkshell_shell_interface;

#ifndef RDKSHELL_SHELL_RDKSHELL_RENDER_FLAGS_ENUM
#define RDKSHELL_SHELL_RDKSHELL_RENDER_FLAGS_ENUM
/**
 * @ingroup iface_rdkshell_shell
 * makes the surface transparent for input
 *
 * Setting this flag means the surface will never receive
 * input events.
 * This flag can only be combined with the overlay flag, and
 * is typically used to display short transient popup
 * surfaces.
 * The flag can be set when the surface is visible or hidden.
 */
enum rdkshell_shell_rdkshell_render_flags {
	RDKSHELL_SHELL_RDKSHELL_RENDER_FLAGS_STANDARD = 0,
	RDKSHELL_SHELL_RDKSHELL_RENDER_FLAGS_OVERLAY = 1,
	RDKSHELL_SHELL_RDKSHELL_RENDER_FLAGS_TRANSPARENT_FOR_INPUT = 2,
};
#endif /* RDKSHELL_SHELL_RDKSHELL_RENDER_FLAGS_ENUM */

#ifndef RDKSHELL_SHELL_CLIENT_STATE_ENUM
#define RDKSHELL_SHELL_CLIENT_STATE_ENUM
enum rdkshell_shell_client_state {
	/**
	 * the client is visible and has focus
	 */
	RDKSHELL_SHELL_CLIENT_STATE_ACTIVE = 0,
	/**
	 * the client is visible but does not have focus
	 */
	RDKSHELL_SHELL_CLIENT_STATE_INACTIVE = 1,
	/**
	 * the client is not visible and does not have focus
	 */
	RDKSHELL_SHELL_CLIENT_STATE_HIDDEN = 2,
	/**
	 * the client is suspended
	 */
	RDKSHELL_SHELL_CLIENT_STATE_SUSPENDED = 3,
};
#endif /* RDKSHELL_SHELL_CLIENT_STATE_ENUM */

#ifndef RDKSHELL_SHELL_VISIBILITY_POLICY_ENUM
#define RDKSHELL_SHELL_VISIBILITY_POLICY_ENUM
enum rdkshell_shell_visibility_policy {
	/**
	 * surfaces are automatically visible when created
	 */
	RDKSHELL_SHELL_VISIBILITY_POLICY_VISIBLE_BY_DEFAULT = 0,
	/**
	 * surfaces are hidden when created.
	 */
	RDKSHELL_SHELL_VISIBILITY_POLICY_HIDDEN_BY_DEFAULT = 1,
};
#endif /* RDKSHELL_SHELL_VISIBILITY_POLICY_ENUM */

#ifndef RDKSHELL_SHELL_ERROR_ENUM
#define RDKSHELL_SHELL_ERROR_ENUM
enum rdkshell_shell_error {
	/**
	 * tried to set notification or popup flag without capability
	 */
	RDKSHELL_SHELL_ERROR_FORBIDDEN = 0,
};
#endif /* RDKSHELL_SHELL_ERROR_ENUM */

/**
 * @ingroup iface_rdkshell_shell
 * @struct rdkshell_shell_interface
 */
struct rdkshell_shell_interface {
	/**
	 * @param id wayland surface id
	 * @param flags bit mask of render flags
	 */
	void (*set_render_flags)(struct wl_client *client,
				 struct wl_resource *resource,
				 uint32_t id,
				 uint32_t flags);
	/**
	 * sets the default visibility policy for surfaces
	 *
	 * Westeros sets all surfaces to visible when they are created,
	 * this clashes with some windowing code (Qt) which expects
	 * surfaces to initially be invisible. This in turn can cause some
	 * artifacts when the surface / window is first created. This API
	 * allows you to change the default policy so the westeros behavior
	 * is matched to the windowing code. The policy can be changed
	 * dynamically and applies to any surfaces created after the call.
	 * @param policy the policy to set
	 * @since 2
	 */
	void (*set_visibility_policy)(struct wl_client *client,
				      struct wl_resource *resource,
				      uint32_t policy);
	/**
	 * signals the window manager that the app has suspended itself
	 *
	 * This should be called by the app after it has received a state
	 * notification to suspend - and it has actually suspended. However
	 * it can also be called out of the blue, if for example in the
	 * Netflix case where you can exist the app via a menu, which will
	 * cause it to suspend rather than shutdown.
	 * @since 3
	 */
	void (*set_suspended)(struct wl_client *client,
			      struct wl_resource *resource);
};

#define RDKSHELL_SHELL_CLIENT_STATE_CHANGED 0
#define RDKSHELL_SHELL_CLOSE 1

/**
 * @ingroup iface_rdkshell_shell
 */
#define RDKSHELL_SHELL_CLIENT_STATE_CHANGED_SINCE_VERSION 1
/**
 * @ingroup iface_rdkshell_shell
 */
#define RDKSHELL_SHELL_CLOSE_SINCE_VERSION 1

/**
 * @ingroup iface_rdkshell_shell
 */
#define RDKSHELL_SHELL_SET_RENDER_FLAGS_SINCE_VERSION 1
/**
 * @ingroup iface_rdkshell_shell
 */
#define RDKSHELL_SHELL_SET_VISIBILITY_POLICY_SINCE_VERSION 2
/**
 * @ingroup iface_rdkshell_shell
 */
#define RDKSHELL_SHELL_SET_SUSPENDED_SINCE_VERSION 3

/**
 * @ingroup iface_rdkshell_shell
 * Sends an client_state_changed event to the client owning the resource.
 * @param resource_ The client's resource
 * @param state the client state
 */
static inline void
rdkshell_shell_send_client_state_changed(struct wl_resource *resource_, uint32_t state)
{
	wl_resource_post_event(resource_, RDKSHELL_SHELL_CLIENT_STATE_CHANGED, state);
}

/**
 * @ingroup iface_rdkshell_shell
 * Sends an close event to the client owning the resource.
 * @param resource_ The client's resource
 */
static inline void
rdkshell_shell_send_close(struct wl_resource *resource_)
{
	wl_resource_post_event(resource_, RDKSHELL_SHELL_CLOSE);
}

#ifdef  __cplusplus
}
#endif

#endif
